<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>청크 · 네더 계산기 — Minimal Pro</title>
  <style>
    :root {
      --bg: #f2f2f7;
      --card: #ffffff;
      --ink: #1c1c1e;
      --muted: #6e6e73;
      --accent: #e53935; /* active tab & CTA */
      --ink-weak: #3a3a3c;
      --grid: #d1d1d6;
      --grid-strong: #8e8e93;
      --radius: 16px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      background: var(--bg);
      color: var(--ink);
    }

    /* Header Tabs */
    header {
      display: grid;
      grid-template-columns: 1fr 1fr;
      background: #111;
      color: #fff;
      position: sticky;
      top: 0; z-index: 5;
    }
    .tab-btn {
      padding: 14px 18px;
      text-align: center;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
      transition: background .2s ease;
    }
    .tab-btn.active { background: var(--accent); }

    main { max-width: 760px; margin: 0 auto; padding: 28px 16px 40px; }

    .card {
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: 0 8px 24px rgba(0,0,0,.06);
      padding: 28px;
    }

    h1 { margin: 0 0 4px; font-size: 28px; letter-spacing: -.02em; }
    .sub { color: var(--muted); margin: 0 0 18px; }

    .row { display: grid; gap: 12px; margin-bottom: 12px; }
    @media (min-width: 520px){ .row { grid-template-columns: 1fr 1fr; } }

    input[type="number"]{
      width: 100%;
      padding: 14px 16px;
      border-radius: 12px;
      border: 1px solid #d2d2d7;
      font-size: 16px;
      background: #fff;
      color: var(--ink);
      outline: none;
    }
    input[type="number"]:focus{ border-color: var(--grid-strong); box-shadow: 0 0 0 3px rgba(229,57,53,.12); }

    .cta {
      appearance: none; -webkit-appearance:none;
      width: 100%;
      padding: 14px 18px; border: 0; border-radius: 999px;
      background: var(--accent); color: #fff; font-weight: 700; font-size: 16px;
      cursor: pointer; margin-top: 8px;
    }

    .out { margin-top: 16px; line-height: 1.6; text-align: center; }
    .out strong { color: var(--ink-weak); }

    /* Canvas block */
    .canvas-wrap { margin-top: 18px; padding: 18px; border: 1px solid #e5e5ea; border-radius: var(--radius); background: #fff; }
    canvas { display:block; margin: 0 auto; max-width: 100%; background:#fff; }
    .hint { color: var(--muted); text-align: center; margin-top: 8px; font-size: 13px; }

    /* Hide sections */
    .hide { display: none; }
  </style>
</head>
<body>
  <header>
    <div id="btnChunk" class="tab-btn active" onclick="showTab('chunk')">청크 계산기</div>
    <div id="btnNether" class="tab-btn" onclick="showTab('nether')">네더 계산기</div>
  </header>

  <main>
    <!-- Chunk Calculator -->
    <section id="tabChunk" class="card">
      <h1>청크 계산기</h1>
      <p class="sub">마인크래프트 좌표를 입력하면 현재 청크와 블록 위치를 시각화합니다.</p>
      <div class="row">
        <input type="number" id="x" placeholder="X 좌표" inputmode="numeric" />
        <input type="number" id="z" placeholder="Z 좌표" inputmode="numeric" />
      </div>
      <button class="cta" id="btnCalcChunk">계산하기</button>
      <div id="chunkOut" class="out"></div>
      <div class="canvas-wrap">
        <canvas id="chunkCanvas" width="520" height="520"></canvas>
        <div class="hint">격자를 클릭하면 해당 블록 좌표로 이동합니다. (16×16: 현재 청크)</div>
      </div>
    </section>

    <!-- Nether Calculator -->
    <section id="tabNether" class="card hide">
      <h1>네더 계산기</h1>
      <p class="sub">오버월드 ↔ 네더 좌표를 변환합니다. (X/Z만)</p>
      <div class="row">
        <label style="display:flex;gap:8px;align-items:center;justify-content:center">
          <input type="radio" name="dir" value="toNether" checked /> 오버월드 → 네더
        </label>
        <label style="display:flex;gap:8px;align-items:center;justify-content:center">
          <input type="radio" name="dir" value="toOver" /> 네더 → 오버월드
        </label>
      </div>
      <div class="row">
        <input type="number" id="nx" placeholder="X 좌표" inputmode="numeric" />
        <input type="number" id="nz" placeholder="Z 좌표" inputmode="numeric" />
      </div>
      <button class="cta" id="btnCalcNether">변환하기</button>
      <div id="netherOut" class="out"></div>
    </section>
  </main>

  <script>
    // --- Tab switching ---
    function showTab(which){
      document.getElementById('btnChunk').classList.toggle('active', which==='chunk');
      document.getElementById('btnNether').classList.toggle('active', which!=='chunk');
      document.getElementById('tabChunk').classList.toggle('hide', which!=='chunk');
      document.getElementById('tabNether').classList.toggle('hide', which==='chunk');
    }

    // --- Chunk calculator state ---
    const xInput = document.getElementById('x');
    const zInput = document.getElementById('z');
    const chunkOut = document.getElementById('chunkOut');
    const canvas = document.getElementById('chunkCanvas');
    const ctx = canvas.getContext('2d');

    const PAD = 40;               // padding around the 16×16 grid
    const GRID = 16;              // blocks per chunk
    const CELL = Math.floor((canvas.width - PAD*2) / GRID); // px per block

    let state = { x: 0, z: 0, chunkX: 0, chunkZ: 0, startX: 0, startZ: 0, endX: 15, endZ: 15 };

    function calcChunk(x, z){
      const chunkX = Math.floor(x / 16);
      const chunkZ = Math.floor(z / 16);
      const startX = chunkX * 16;
      const startZ = chunkZ * 16;
      const endX = startX + 15;
      const endZ = startZ + 15;
      state = { x, z, chunkX, chunkZ, startX, startZ, endX, endZ };
      renderChunk();
      chunkOut.innerHTML = `현재 좌표: <strong>(${x}, ${z})</strong><br>`+
        `청크 좌표: <strong>(${chunkX}, ${chunkZ})</strong><br>`+
        `시작: <strong>X=${startX}, Z=${startZ}</strong><br>`+
        `끝: <strong>X=${endX}, Z=${endZ}</strong>`;
    }

    function renderChunk(){
      // helpers for pretty labels (no overlap)
      function roundRect(c,x,y,w,h,r){
        c.beginPath();
        c.moveTo(x+r,y); c.arcTo(x+w,y,x+w,y+h,r); c.arcTo(x+w,y+h,x,y+h,r);
        c.arcTo(x,y+h,x,y,r); c.arcTo(x,y,x+w,y,r); c.closePath();
      }
      function chipTL(text,x,y){ // draw small pill at top-left anchor
        ctx.save();
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        const w = ctx.measureText(text).width + 12; const h = 20;
        ctx.fillStyle = 'rgba(255,255,255,.96)'; ctx.strokeStyle = '#d1d1d6'; ctx.lineWidth = 1;
        roundRect(ctx,x,y,w,h,8); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#6e6e73'; ctx.textBaseline = 'middle'; ctx.fillText(text, x+6, y+h/2+0.5);
        ctx.restore();
      }
      function chipTR(text,x,y){ // anchor at top-right (x,y is right edge)
        ctx.save();
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        const w = ctx.measureText(text).width + 12; const h = 20; const left = x - w;
        ctx.fillStyle = 'rgba(255,255,255,.96)'; ctx.strokeStyle = '#d1d1d6'; ctx.lineWidth = 1;
        roundRect(ctx,left,y,w,h,8); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#6e6e73'; ctx.textBaseline = 'middle'; ctx.fillText(text, left+6, y+h/2+0.5);
        ctx.restore();
      }

      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const GX = PAD; const GY = PAD;           // grid origin
      const gridW = CELL*GRID; const gridH = CELL*GRID;

      // grid bg + border
      ctx.fillStyle = '#fff';
      ctx.fillRect(GX-1, GY-1, gridW+2, gridH+2);
      ctx.lineWidth = 1; ctx.strokeStyle = '#d1d1d6';
      for(let r=0;r<GRID;r++){
        for(let c=0;c<GRID;c++){
          const x = GX + c*CELL; const y = GY + r*CELL;
          ctx.strokeRect(x,y,CELL,CELL);
        }
      }
      ctx.lineWidth = 2; ctx.strokeStyle = '#8e8e93';
      ctx.strokeRect(GX, GY, gridW, gridH);

      // axis labels as non-overlapping chips
      chipTL(`X ${state.endX}`, GX-10, GY-28);             // above-left of grid
      chipTL(`X ${state.startX}`, GX-10, GY+gridH+8);      // left-bottom below grid
      chipTL(`Z ${state.startZ}`, GX,     GY+gridH+8);     // bottom-left below grid
      chipTR(`Z ${state.endZ}`, GX+gridW, GY+gridH+8);     // bottom-right below grid

      // highlight selected block (player position inside chunk)
      const selC = state.x - state.startX; // 0..15
      const selR = state.z - state.startZ; // 0..15
      if(selC>=0 && selC<16 && selR>=0 && selR<16){
        const sx = GX + selC*CELL; const sy = GY + selR*CELL;
        ctx.fillStyle = 'rgba(229,57,53,.9)';
        ctx.fillRect(sx+2, sy+2, CELL-4, CELL-4);
      }
    }`, 8, 8);                 // top-left X end
      ctx.textBaseline = 'bottom';
      ctx.fillText(`X ${state.startX}`, 8, canvas.height-8); // bottom-left X start
      ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
      ctx.fillText(`Z ${state.endZ}`, canvas.width-8, canvas.height-8); // bottom-right Z end
      ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
      ctx.fillText(`Z ${state.startZ}`, PAD, canvas.height-8); // bottom-left Z start (near grid)

      // grid origin (top-left block of chunk)
      const GX = PAD; const GY = PAD;

      // grid background
      ctx.fillStyle = '#fff';
      ctx.fillRect(GX-1, GY-1, CELL*GRID+2, CELL*GRID+2);

      // draw cells & thick border
      ctx.lineWidth = 1; ctx.strokeStyle = '#d1d1d6';
      for(let r=0; r<GRID; r++){
        for(let c=0; c<GRID; c++){
          const x = GX + c*CELL;
          const y = GY + r*CELL;
          ctx.strokeRect(x, y, CELL, CELL);
        }
      }
      ctx.lineWidth = 2; ctx.strokeStyle = '#8e8e93';
      ctx.strokeRect(GX, GY, CELL*GRID, CELL*GRID);

      // highlight selected block (player position inside chunk)
      const selC = state.x - state.startX; // 0..15
      const selR = state.z - state.startZ; // 0..15
      if(selC>=0 && selC<16 && selR>=0 && selR<16){
        const sx = GX + selC*CELL;
        const sy = GY + selR*CELL;
        ctx.fillStyle = 'rgba(229,57,53,.9)';
        ctx.fillRect(sx+2, sy+2, CELL-4, CELL-4);
      }
    }

    // click to set new X/Z within this chunk
    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const cx = e.clientX - rect.left; const cy = e.clientY - rect.top;
      const GX = PAD; const GY = PAD;
      if(cx<GX || cy<GY || cx>GX+CELL*GRID || cy>GY+CELL*GRID) return; // outside
      const col = Math.floor((cx - GX) / CELL);   // 0..15
      const row = Math.floor((cy - GY) / CELL);   // 0..15
      const newX = state.startX + col;
      const newZ = state.startZ + row;
      xInput.value = newX; zInput.value = newZ;
      calcChunk(newX, newZ);
    });

    // Enter key triggers calc
    function bindEnter(el){ el.addEventListener('keydown', e=>{ if(e.key==='Enter') doCalcChunk(); }); }
    bindEnter(xInput); bindEnter(zInput);

    function doCalcChunk(){
      const x = parseInt(xInput.value, 10);
      const z = parseInt(zInput.value, 10);
      if(Number.isFinite(x) && Number.isFinite(z)) calcChunk(x, z);
    }
    document.getElementById('btnCalcChunk').addEventListener('click', doCalcChunk);

    // seed with 0,0 for first render
    calcChunk(0,0);

    // --- Nether converter ---
    const btnCalcNether = document.getElementById('btnCalcNether');
    const nx = document.getElementById('nx');
    const nz = document.getElementById('nz');
    const netherOut = document.getElementById('netherOut');

    btnCalcNether.addEventListener('click', ()=>{
      const X = parseInt(nx.value, 10);
      const Z = parseInt(nz.value, 10);
      if(!Number.isFinite(X) || !Number.isFinite(Z)){ netherOut.textContent = '좌표를 정확히 입력하세요.'; return; }
      const dir = (document.querySelector('input[name="dir"]:checked')||{}).value || 'toNether';
      if(dir==='toNether'){
        const rx = Math.floor(X/8); const rz = Math.floor(Z/8);
        netherOut.innerHTML = `<strong>오버월드 → 네더</strong><br/>(${X}, ${Z}) → <strong>(${rx}, ${rz})</strong>`;
      } else {
        const rx = X*8; const rz = Z*8;
        netherOut.innerHTML = `<strong>네더 → 오버월드</strong><br/>(${X}, ${Z}) → <strong>(${rx}, ${rz})</strong>`;
      }
    });
  </script>
</body>
</html>
