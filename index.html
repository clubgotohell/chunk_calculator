<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>청크 · 네더 계산기 — Final Final</title>
  <style>
    :root{
      --bg:#f2f2f7; --card:#fff; --ink:#1c1c1e; --muted:#6e6e73;
      --accent:#e53935; --r:16px; --grid:#d1d1d6; --grid-strong:#8e8e93;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--ink)}
    header{display:grid;grid-template-columns:1fr 1fr;background:#111;color:#fff;position:sticky;top:0;z-index:5}
    .tabbtn{padding:14px 18px;text-align:center;font-weight:700;cursor:pointer;user-select:none}
    .tabbtn.active{background:var(--accent)}
    main{max-width:760px;margin:0 auto;padding:28px 16px 40px}
    .card{background:var(--card);border-radius:var(--r);box-shadow:0 8px 24px rgba(0,0,0,.06);padding:28px}
    h1{margin:0 0 4px;font-size:28px;letter-spacing:-.02em}
    .sub{color:var(--muted);margin:0 0 18px}
    .row{display:grid;gap:12px;margin-bottom:12px}
    @media (min-width:520px){.row{grid-template-columns:1fr 1fr}}
    .field{position:relative}
    input[type="text"]{width:100%;padding:14px 48px 14px 16px;border-radius:12px;border:1px solid #d2d2d7;font-size:16px;background:#fff;color:var(--ink);outline:none}
    input[type="text"]:focus{border-color:var(--grid-strong);box-shadow:0 0 0 3px rgba(229,57,53,.12)}
    .sign{position:absolute;right:8px;top:50%;transform:translateY(-50%);width:32px;height:32px;border-radius:10px;border:1px solid #d2d2d7;background:#fff;font-weight:700;cursor:pointer}
    .sign:active{background:#f4f4f4}
    .cta{width:100%;padding:14px 18px;border:0;border-radius:999px;background:var(--accent);color:#fff;font-weight:700;font-size:16px;cursor:pointer;margin-top:8px}
    .out{margin-top:16px;line-height:1.6;text-align:center}
    .out strong{color:#2c2c2e}

    /* 요청: 그래프만 보이게(외곽 박스/테두리 제거) */
    .canvaswrap{margin-top:18px;padding:0;border:none;border-radius:0;background:transparent}
    canvas{display:block;margin:0 auto;background:transparent;touch-action:manipulation}

    .hint{color:var(--muted);text-align:center;margin-top:8px;font-size:13px}
    .hide{display:none}
    .radios{display:flex;gap:16px;justify-content:center;margin-bottom:8px}
    .radios label{display:flex;gap:8px;align-items:center}
  </style>
</head>
<body>
  <header>
    <div id="navChunk" class="tabbtn active">청크 계산기</div>
    <div id="navNether" class="tabbtn">네더 계산기</div>
  </header>

  <main>
    <!-- CHUNK -->
    <section id="secChunk" class="card">
      <h1>청크 계산기</h1>
      <p class="sub">좌표를 입력하면 현재 청크(16×16)와 블록 위치를 시각화합니다.</p>
      <div class="row">
        <div class="field">
          <input type="text" id="x"  placeholder="X 좌표" inputmode="numeric" pattern="-?[0-9]*"/>
          <button class="sign" data-t="x">±</button>
        </div>
        <div class="field">
          <input type="text" id="z"  placeholder="Z 좌표" inputmode="numeric" pattern="-?[0-9]*"/>
          <button class="sign" data-t="z">±</button>
        </div>
      </div>
      <button class="cta" id="btnChunk">계산하기</button>
      <div id="chunkOut" class="out"></div>
      <div class="canvaswrap" id="canvasWrap">
        <canvas id="chunkCanvas"></canvas>
        <div class="hint">격자를 클릭하면 해당 블록 좌표로 이동합니다. (16×16: 현재 청크)</div>
      </div>
    </section>

    <!-- NETHER -->
    <section id="secNether" class="card hide">
      <h1>네더 계산기</h1>
      <p class="sub">오버월드 ↔ 네더 좌표를 변환합니다. (X/Z)</p>
      <div class="radios">
        <label><input type="radio" name="dir" value="toNether" checked/> 오버월드 → 네더</label>
        <label><input type="radio" name="dir" value="toOver"/> 네더 → 오버월드</label>
      </div>
      <div class="row">
        <div class="field">
          <input type="text" id="nx" placeholder="X 좌표" inputmode="numeric" pattern="-?[0-9]*"/>
          <button class="sign" data-t="nx">±</button>
        </div>
        <div class="field">
          <input type="text" id="nz" placeholder="Z 좌표" inputmode="numeric" pattern="-?[0-9]*"/>
          <button class="sign" data-t="nz">±</button>
        </div>
      </div>
      <button class="cta" id="btnNether">변환하기</button>
      <div id="netherOut" class="out"></div>
    </section>
  </main>

  <script>
  (function(){
    // ===== helpers =====
    const $ = (id)=>document.getElementById(id);
    const fmt = (n)=>n.toLocaleString('en-US');
    const toInt = (el)=>{ const s=String(el.value||'').trim(); const m = s.match(/^-?\d+$/)||s.match(/^-?\d+/); return m?parseInt(m[0],10):NaN; };
    const toggleSign = (el)=>{
      let s = String(el.value||'').trim();
      if(!/^-?\d+$/.test(s)) s = '0';
      el.value = s.startsWith('-') ? s.slice(1) : '-'+s;
    };
    document.querySelectorAll('.sign').forEach(btn=>{
      btn.addEventListener('click', ()=> toggleSign($(btn.dataset.t)));
    });

    // ===== tabs =====
    const navChunk=$('navChunk'), navNether=$('navNether');
    const secChunk=$('secChunk'), secNether=$('secNether');
    function show(which){
      const on = which==='chunk';
      navChunk.classList.toggle('active', on);
      navNether.classList.toggle('active', !on);
      secChunk.classList.toggle('hide', !on);
      secNether.classList.toggle('hide', on);
    }
    navChunk.addEventListener('click', ()=>show('chunk'));
    navNether.addEventListener('click', ()=>show('nether'));

    // ===== canvas (responsive square + DPR) =====
    const wrap = $('canvasWrap');
    const canvas = $('chunkCanvas');
    const ctx = canvas.getContext('2d');

    const PAD  = 40;   // padding inside canvas around grid
    const GRID = 16;   // 16×16
    let cssSize = 520; // set by wrapper
    let dpr = 1;
    let CELL = 20;     // px per block

    function fitCanvas(){
      const w = Math.max(260, Math.min(520, wrap.clientWidth)); // square
      cssSize = w;
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width  = Math.round(cssSize * dpr);
      canvas.height = Math.round(cssSize * dpr);
      canvas.style.width  = cssSize + 'px';
      canvas.style.height = cssSize + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
      CELL = Math.floor((cssSize - PAD*2) / GRID);
      render();
    }
    window.addEventListener('resize', fitCanvas);
    window.addEventListener('orientationchange', fitCanvas);

    // ===== chunk state =====
    let S = { x:0, z:0, chunkX:0, chunkZ:0, startX:0, startZ:0, endX:15, endZ:15 };

    function compute(x,z){
      const chunkX = Math.floor(x/16), chunkZ = Math.floor(z/16);
      const startX = chunkX*16,        startZ = chunkZ*16;
      const endX   = startX+15,        endZ   = startZ+15;
      S = { x, z, chunkX, chunkZ, startX, startZ, endX, endZ };
      updateOut(); render();
    }

    function updateOut(){
      $('chunkOut').innerHTML =
        `현재 좌표: <strong>(${fmt(S.x)}, ${fmt(S.z)})</strong><br>`+
        `청크 좌표: <strong>(${fmt(S.chunkX)}, ${fmt(S.chunkZ)})</strong><br>`+
        `시작: <strong>X=${fmt(S.startX)}, Z=${fmt(S.startZ)}</strong><br>`+
        `끝: <strong>X=${fmt(S.endX)}, Z=${fmt(S.endZ)}</strong>`;
    }

    // ===== chip labels (no overlap / no clipping) =====
    function roundRect(c,x,y,w,h,r){
      c.beginPath();
      c.moveTo(x+r,y); c.arcTo(x+w,y,x+w,y+h,r); c.arcTo(x+w,y+h,x,y+h,r);
      c.arcTo(x,y+h,x,y,r); c.arcTo(x,y,x+w,y,r); c.closePath();
    }
    function chip(text, x, y){ // left-anchored pill
      ctx.save();
      ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
      const w = ctx.measureText(text).width + 12, h = 20;
      x = Math.max(6, Math.min(x, cssSize - w - 6)); y = Math.max(6, Math.min(y, cssSize - h - 6));
      ctx.fillStyle='rgba(255,255,255,.96)'; ctx.strokeStyle='#d1d1d6'; ctx.lineWidth=1;
      roundRect(ctx,x,y,w,h,8); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#6e6e73'; ctx.textBaseline='middle'; ctx.fillText(text,x+6,y+h/2+0.5);
      ctx.restore();
    }
    function chipRight(text, rightX, y){ // right-anchored pill
      ctx.save();
      ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
      const w = ctx.measureText(text).width + 12, h = 20;
      const left = Math.max(6, Math.min(rightX - w, cssSize - w - 6));
      y = Math.max(6, Math.min(y, cssSize - h - 6));
      ctx.fillStyle='rgba(255,255,255,.96)'; ctx.strokeStyle='#d1d1d6'; ctx.lineWidth=1;
      roundRect(ctx,left,y,w,h,8); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#6e6e73'; ctx.textBaseline='middle'; ctx.fillText(text,left+6,y+h/2+0.5);
      ctx.restore();
    }

    function render(){
      const GX = PAD, GY = PAD;
      const gridW = CELL*GRID, gridH = CELL*GRID;

      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // grid lines only (no thick outer border, no bg box)
      ctx.lineWidth=1; ctx.strokeStyle='#d1d1d6';
      for(let r=0;r<=GRID;r++){
        const y = GY + r*CELL;
        ctx.beginPath(); ctx.moveTo(GX, y); ctx.lineTo(GX+gridW, y); ctx.stroke();
      }
      for(let c=0;c<=GRID;c++){
        const x = GX + c*CELL;
        ctx.beginPath(); ctx.moveTo(x, GY); ctx.lineTo(x, GY+gridH); ctx.stroke();
      }

      // labels: X(left top/bottom), Z(bottom left/right)
      ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
      const xEndTxt   = `X ${fmt(S.endX)}`;
      const xStartTxt = `X ${fmt(S.startX)}`;

      const wXend   = ctx.measureText(xEndTxt).width + 12;
      const wXstart = ctx.measureText(xStartTxt).width + 12;

      const leftRail = GX - 8;
      const bottomY = GY + gridH + 8;
      const topY    = GY - 10;

      // place and clamp
      chip(xEndTxt,   leftRail - wXend,   topY);
      // stack X(start) 26px 위로 올려 Z(start)와 겹치지 않게
      chip(xStartTxt, leftRail - wXstart, bottomY - 26);

      chip(`Z ${fmt(S.startZ)}`, GX,            bottomY);
      chipRight(`Z ${fmt(S.endZ)}`, GX + gridW, bottomY);

      // current block highlight
      const col = S.x - S.startX, row = S.z - S.startZ;
      if(col>=0 && col<16 && row>=0 && row<16){
        const sx = GX + col*CELL, sy = GY + row*CELL;
        ctx.fillStyle='rgba(229,57,53,.9)';
        ctx.fillRect(sx+2, sy+2, CELL-4, CELL-4);
      }
    }

    // click -> move inside current chunk
    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
      const GX = PAD, GY = PAD, gridW = CELL*GRID, gridH = CELL*GRID;
      if(cx<GX || cy<GY || cx>GX+gridW || cy>GY+gridH) return;
      const col = Math.floor((cx-GX)/CELL), row = Math.floor((cy-GY)/CELL);
      const nx = S.startX + col, nz = S.startZ + row;
      $('x').value = nx; $('z').value = nz;
      compute(nx,nz);
    });

    // inputs
    function recalcFromInputs(){
      const x = toInt($('x'));
      const z = toInt($('z'));
      if(!Number.isFinite(x) || !Number.isFinite(z)) return;
      compute(x,z);
    }
    $('btnChunk').addEventListener('click', recalcFromInputs);
    ['x','z','nx','nz'].forEach(id=>$(id)?.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); (id==='nx'||id==='nz')?netherCalc():recalcFromInputs(); }}));

    // initial
    fitCanvas();
    compute(0,0);

    // ===== Nether converter =====
    function netherCalc(){
      const X = toInt($('nx'));
      const Z = toInt($('nz'));
      const out = $('netherOut');
      if(!Number.isFinite(X) || !Number.isFinite(Z)){ out.textContent='좌표를 정확히 입력하세요.'; return; }
      const dir = (document.querySelector('input[name="dir"]:checked')||{}).value || 'toNether';
      out.innerHTML = (dir==='toNether')
        ? `<strong>오버월드 → 네더</strong><br>(${fmt(X)}, ${fmt(Z)}) → <strong>(${fmt(Math.floor(X/8))}, ${fmt(Math.floor(Z/8))})</strong>`
        : `<strong>네더 → 오버월드</strong><br>(${fmt(X)}, ${fmt(Z)}) → <strong>(${fmt(X*8)}, ${fmt(Z*8)})</strong>`;
    }
    $('btnNether').addEventListener('click', netherCalc);
  })();
  </script>
</body>
</html>
